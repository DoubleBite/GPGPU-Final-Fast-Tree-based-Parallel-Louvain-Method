#include <thrust/copy.h>
#include <thrust/reduce.h>
#include <thrust/sort.h>
#include <thrust/scatter.h>
#include <thrust/transform.h>
#include <thrust/sequence.h>
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
#include <thrust/logical.h>
#include <thrust/partition.h>
#include <thrust/extrema.h>

#include "parallel_louvain.h"
#include "louvain_utils.h"






/**
	Host function to perform Louvain's method.
*/
void parallelLouvain(Dec_vec &d_nodes, Dec_vec &d_neighs, Dec_vec &d_oWeights, Dec_vec &d_iWeights){

    Dec_vec::iterator dev_ptr = thrust::max_element(d_nodes.begin(), d_nodes.end());
    int n1 = *dev_ptr;
    Dec_vec::iterator dev_ptr = thrust::max_element(d_neighs.begin(), d_neighs.end());
    int n2 = *dev_ptr;
    int n = std::max(n1, n2);
    int m = thrust::reduce(d_oWeights.begin(), d_oWeights.end()) + thrust::reduce(d_iWeights.begin(), d_iWeights.end());

    // Generate initial partition
    Dec_vec current_partition(n); 
    thrust::sequence(indices.begin(), indices.end());

    // current partition
    Dec_vec d_comm_map(current_partition)


    while(1){
        // Get the partition generated by this pass.
        bool is_terminate = onePassLouvain(d_comm_map, d_nodes, d_neighs, d_oWeights, d_iWeights, n, m);
        if(is_terminate)
            break;

		// Reassign community map
		n = reassign(d_comm_map);

        // Convert to this partition
        convertToCommunity(d_comm_map, current_partition);

        // Generate data for next round
        mergeCommunity(d_nodes, d_neighs, d_oWeights, d_iWeights);

    }

    thrust::copy(current_partition.begin(), current_partition.end(), std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;

    return;
}


/**

*/
int onePassLouvain(Dec_vec &d_comm_map, Dec_vec d_nodes, Dec_vec d_neighs, Dec_vec d_oWeights, Dec_vec d_iWeights
        , int n, int m){


    // Calculate node weights
	Dec_vec d_node_oWeights(n);
	Dec_vec d_node_iWeights(n);
	calculateWeights(d_node_oWeights, d_nodes, d_oWeights);
	calculateWeights(d_node_iWeights, d_neighs, d_iWeights);

    int counter = 0;
    bool is_assign;
    do{
        is_assign = oneIterLouvain(d_comm_map, d_nodes, d_neighs, d_oWeights, d_iWeights, d_nodeOWeights, d_nodeIWeights, m);
        counter+=1;
    }while(is_assign);



    return (counter==1);
}

int reassign(Dec_vec &vec){

    Dec_vec tmp_vec(vec);
    thrust::sort(tmp_vec.begin(),tmp_vec.end());
    Dec_vec::iterator new_end = thrust::unique(tmp_vec.begin(),tmp_vec.end());
    tmp_vec.resize(new_end-tmp_vec.begin());
    
    
    Dec_vec indices(tmp_vec.size()); 
    thrust::sequence(indices.begin(), indices.end());    

    Dec_vec::iterator dev_ptr = thrust::max_element(tmp_vec.begin(), tmp_vec.end());
    int max_comm = *dev_ptr;
    Dec_vec tmp_mapping(max_comm+1);


    thrust::scatter(indices.begin(), indices.end(), tmp_vec.begin(), tmp_mapping.begin());
    auto ff = [=]  __device__ (int x) {return tmp_mapping[x];};
    thrust::transform(vec.begin(), vec.end(), vec.begin(), ff);

    return max_comm+1;
}

void mergeCommunity(const Dec_vec &d_comm_map, Dec_vec &d_nodes, Dec_vec &d_neighs, Dec_vec &d_oWeights, Dec_vec &d_iWeights){

    convertIDToCommunity(d_comm_map, d_nodes);
    convertIDToCommunity(d_comm_map, d_neighs);
    sortByFirstTwo(d_nodes, d_neighs, d_oWeights, d_iWeights);
    reduceByFirstTwo(d_nodes, d_neighs, d_oWeights, d_iWeights);
    return;
}


void FNC(const Dec_vec &d_comm_map, Dec_vec &d_nodes, Dec_vec &d_neighs, Dec_vec &d_oWeights, Dec_vec &d_iWeights){

	convertToCommunity(d_comm_map, d_neighs);
    sortByFirstTwo(d_nodes, d_neighs, d_oWeights, d_iWeights);
    reduceByFirstTwo(d_nodes, d_neighs, d_oWeights, d_iWeights);

	// For debug
	thrust::copy(d_nodes.begin(), d_nodes.end(), std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;
    thrust::copy(d_neighs.begin(), d_neighs.end(), std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;
    thrust::copy(d_oWeights.begin(), d_oWeights.end(), std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;
    thrust::copy(d_iWeights.begin(), d_iWeights.end(), std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;

	return;
}

bool FBM(const Dec_vec &d_nodes, const Dec_vec &d_neighs, const Dec_vec &d_oWeights, const Dec_vec &d_iWeights
    , Dec_vec &d_map, const Dec_vec &d_nodeOWeights, const Dec_vec &d_nodeIWeights
    , const Dec_vec &d_commOWeights, const Dec_vec &d_commIWeights, const int m){

    // Allocate a vector to store modularity gains
    thrust::device_vector<float> d_mod_gains(new_length);

    computeModularityGain(d_mod_gains, d_nodes, d_neighs, d_oWeights, d_iWeights
    , d_comm_map, d_node_oWeights, d_node_iWeights, d_comm_oWeights, d_comm_iWeights, m);
	
	// For debug
    thrust::copy(d_mod_gains.begin(), d_mod_gains.end(), std::ostream_iterator<float>(std::cout," "));
    cout<<endl;

    bool is_assign = assignNewCommunity(d_comm_map, d_nodes, d_neighs, d_mod_gains);
    // For debug
    thrust::copy(d_comm_map.begin(), d_comm_map.end(), std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;
    return is_assign;
    }
}

bool oneIterLouvain(Dec_vec &d_comm_map, Dec_vec d_nodes, Dec_vec d_neighs, Dec_vec d_oWeights, Dec_vec d_iWeights
        , const Dec_vec &d_node_oWeights, const Dec_vec &d_node_iWeights, int m){


	FNC(d_comm_map, d_nodes, d_neighs, d_oWeights, d_iWeights);


    // Get the max number of community and calculate community weights
    Dec_vec::iterator dev_ptr = thrust::max_element(d_comm_map.begin(), d_comm_map.end());
    int max_comm = *dev_ptr;
    Dec_vec d_comm_oWeights(max_comm+1);
    Dec_vec d_comm_iWeights(max_comm+1);
    calculateCommunityWeights(d_comm_oWeights, d_comm_iWeights, d_comm_map, d_node_oWeights, d_node_iWeights);

	bool is_assign = FBM(d_nodes, d_neighs, d_oWeights, d_iWeights
    					, d_comm_map, d_node_oWeights, d_node_iWeights, d_comm_oWeights, d_comm_iWeights, m);


    return is_assign;
}




void calculateCommunityWeights(Dec_vec  &d_comm_oWeights, Dec_vec  &d_comm_iWeights
        , const Dec_vec &d_comm_map, Dec_vec d_nodes, Dec_vec d_neighs, Dec_vec &d_node_oWeights, Dec_vec &d_node_iWeights){

    convertIDToCommunity(d_comm_map, d_nodes);
    convertIDToCommunity(d_comm_map, d_neighs);
	calculateWeights(d_comm_oWeights, d_nodes, d_oWeights);
	calculateWeights(d_comm_iWeights, d_neighs, d_node_iWeights);

    return;
}




/*
*/
void computeModularityGain(thrust::device_vector<float> &d_mod_gains 
    , const Dec_vec &d_nodes, const Dec_vec &d_neighs, const Dec_vec &d_oWeights, const Dec_vec &d_iWeights
    , const Dec_vec &d_map, const Dec_vec &d_nodeOWeights, const Dec_vec &d_nodeIWeights
    , const Dec_vec &d_commOWeights, const Dec_vec &d_commIWeights, const int m){

    int length = d_mod_gains.size();

    // Calculate first part: kic + kci
    thrust::transform(d_oWeights.begin(), d_oWeights.begin()+length, d_iWeights.begin(), d_mod_gains.begin(), thrust::plus<int>());

    // Calculate second part: kiout*kcin + kiin*kcout
    thrust::device_vector<float> tmp(length);
    const int* d_nOWeights_ptr = thrust::raw_pointer_cast(&d_nodeOWeights[0]);
    const int* d_nIWeights_ptr = thrust::raw_pointer_cast(&d_nodeIWeights[0]);
    const int* d_cOWeights_ptr = thrust::raw_pointer_cast(&d_commOWeights[0]);
    const int* d_cIWeights_ptr = thrust::raw_pointer_cast(&d_commIWeights[0]);

    auto ff = [=]  __device__ (int node, int nei_comm) {
        float result = d_nOWeights_ptr[node]*d_cIWeights_ptr[nei_comm] 
                        + d_nIWeights_ptr[node]*d_cOWeights_ptr[nei_comm];
        result = result/m;
        return result;
    };
    thrust::transform(d_nodes.begin(), d_nodes.begin()+length, d_neighs.begin(), tmp.begin(), ff);

    // Calculate first part + second part
    auto ff2 = [=]  __device__ (float first, float second) {  return (first-second)/m; };
    thrust::transform(d_mod_gains.begin(), d_mod_gains.begin()+length, tmp.begin(), d_mod_gains.begin(), ff2);
    tmp.clear();
    thrust::device_vector<float>().swap(tmp);

    // Calculate status map to indicate whether node is in the same community.
    Dec_vec status_map(length);
    const int* d_map_ptr = thrust::raw_pointer_cast(&d_map[0]);
    auto ff3 = [=]  __device__ (int node, int nei_comm) {  return d_map_ptr[node]!=nei_comm; };
    thrust::transform(d_nodes.begin(), d_nodes.begin()+length, d_neighs.begin(), status_map.begin(), ff3);
    thrust::copy(status_map.begin(), status_map.begin()+length, std::ostream_iterator<int>(std::cout,"  "));
    cout<<endl;

    // Calculate final result by specifying the node which is in the same community as its neighbor to zero.
    thrust::transform(d_mod_gains.begin(), d_mod_gains.begin()+length, status_map.begin(), d_mod_gains.begin(), thrust::multiplies<float>());

    return;

}



bool isEnd(const thrust::device_vector<float> &d_mod_gains){

    // Check whether any of the reassignment gets modularity gain. If no, just return.
    auto greater_than_zero = [=]  __device__ (float gain) {  return gain>0; };
    bool is_proceed = thrust::any_of(d_mod_gains.begin(), d_mod_gains.end(), greater_than_zero);

    return !is_proceed;
}




bool assignNewCommunity(Dec_vec &d_comm_map, Dec_vec &d_nodes, Dec_vec &d_neighs, thrust::device_vector<float> &d_mod_gains){

	sortByFirstTwo3(d_nodes, d_mod_gains, d_neighs);
    thrust::pair<Dec_vec::iterator,Dec_vec::iterator> new_end;

    Dec_vec tmp(d_nodes.size());
    new_end = thrust::unique_by_key_copy(d_nodes.begin(), d_nodes.end(), d_mod_gains.begin(), tmp.begin(), d_mod_gains.begin());

    int new_length = new_end.second - d_mod_gains.begin();
    int sum = thrust::reduce(d_mod_gains.begin(), d_mod_gains.begin() + new_length);
    if(sum<=0)
        return false;
    else{
        new_end = thrust::unique_by_key_copy(d_nodes.begin(), d_nodes.end(), d_neighs.begin(), d_nodes.begin(), d_comm_map.begin());
        return true;
    }
    
}
